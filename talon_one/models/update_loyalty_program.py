# coding: utf-8

"""
    Talon.One API

    Use the Talon.One API to integrate with your application and to manage applications and campaigns:  - Use the operations in the [Integration API section](#integration-api) are used to integrate with our platform - Use the operation in the [Management API section](#management-api) to manage applications and campaigns.  ## Determining the base URL of the endpoints  The API is available at the same hostname as your Campaign Manager deployment. For example, if you access the Campaign Manager at `https://yourbaseurl.talon.one/`, the URL for the [updateCustomerSessionV2](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint is `https://yourbaseurl.talon.one/v2/customer_sessions/{Id}` 

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from talon_one.models.code_generator_settings import CodeGeneratorSettings
from talon_one.models.new_loyalty_tier import NewLoyaltyTier
from typing import Optional, Set
from typing_extensions import Self

class UpdateLoyaltyProgram(BaseModel):
    """
    UpdateLoyaltyProgram
    """ # noqa: E501
    title: Optional[StrictStr] = Field(default=None, description="The display title for the Loyalty Program.")
    description: Optional[StrictStr] = Field(default=None, description="Description of our Loyalty Program.")
    subscribed_applications: Optional[List[StrictInt]] = Field(default=None, description="A list containing the IDs of all applications that are subscribed to this Loyalty Program.", alias="subscribedApplications")
    default_validity: Optional[StrictStr] = Field(default=None, description="The default duration after which new loyalty points should expire. Can be 'unlimited' or a specific time. The time format is a number followed by one letter indicating the time unit, like '30s', '40m', '1h', '5D', '7W', or 10M'. These rounding suffixes are also supported: - '_D' for rounding down. Can be used as a suffix after 'D', and signifies the start of the day. - '_U' for rounding up. Can be used as a suffix after 'D', 'W', and 'M', and signifies the end of the day, week, and month. ", alias="defaultValidity")
    default_pending: Optional[StrictStr] = Field(default=None, description="The default duration of the pending time after which points should be valid. Accepted values: 'immediate', 'on_action' or a specific time. The time format is a number followed by one letter indicating the time unit, like '30s', '40m', '1h', '5D', '7W', or 10M'. These rounding suffixes are also supported: - '_D' for rounding down. Can be used as a suffix after 'D', and signifies the start of the day. - '_U' for rounding up. Can be used as a suffix after 'D', 'W', and 'M', and signifies the end of the day, week, and month. ", alias="defaultPending")
    allow_subledger: Optional[StrictBool] = Field(default=None, description="Indicates if this program supports subledgers inside the program.", alias="allowSubledger")
    users_per_card_limit: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The max amount of user profiles with whom a card can be shared. This can be set to 0 for no limit. This property is only used when `cardBased` is `true`. ", alias="usersPerCardLimit")
    sandbox: Optional[StrictBool] = Field(default=None, description="Indicates if this program is a live or sandbox program. Programs of a given type can only be connected to Applications of the same type.")
    program_join_policy: Optional[StrictStr] = Field(default=None, description="The policy that defines when the customer joins the loyalty program.   - `not_join`: The customer does not join the loyalty program but can still earn and spend loyalty points.       **Note**: The customer does not have a program join date.   - `points_activated`: The customer joins the loyalty program only when their earned loyalty points become active for the first time.   - `points_earned`: The customer joins the loyalty program when they earn loyalty points for the first time. ", alias="programJoinPolicy")
    tiers_expiration_policy: Optional[StrictStr] = Field(default=None, description="The policy that defines how tier expiration, used to reevaluate the customer's current tier, is determined.  - `tier_start_date`: The tier expiration is relative to when the customer joined the current tier.  - `program_join_date`: The tier expiration is relative to when the customer joined the loyalty program.  - `customer_attribute`: The tier expiration is determined by a custom customer attribute.  - `absolute_expiration`: The tier is reevaluated at the start of each tier cycle. For this policy, it is required to provide a `tierCycleStartDate`. ", alias="tiersExpirationPolicy")
    tier_cycle_start_date: Optional[datetime] = Field(default=None, description="Timestamp at which the tier cycle starts for all customers in the loyalty program.  **Note**: This is only required when the tier expiration policy is set to `absolute_expiration`. ", alias="tierCycleStartDate")
    tiers_expire_in: Optional[StrictStr] = Field(default=None, description="The amount of time after which the tier expires and is reevaluated.  The time format is an **integer** followed by one letter indicating the time unit. Examples: `30s`, `40m`, `1h`, `5D`, `7W`, `10M`, `15Y`.  Available units:  - `s`: seconds - `m`: minutes - `h`: hours - `D`: days - `W`: weeks - `M`: months - `Y`: years  You can round certain units up or down: - `_D` for rounding down days only. Signifies the start of the day. - `_U` for rounding up days, weeks, months and years. Signifies the end of the day, week, month or year. ", alias="tiersExpireIn")
    tiers_downgrade_policy: Optional[StrictStr] = Field(default=None, description="The policy that defines how customer tiers are downgraded in the loyalty program after tier reevaluation.  - `one_down`: If the customer doesn't have enough points to stay in the current tier, they are downgraded by one tier.  - `balance_based`: The customer's tier is reevaluated based on the amount of active points they have at the moment. ", alias="tiersDowngradePolicy")
    card_code_settings: Optional[CodeGeneratorSettings] = Field(default=None, alias="cardCodeSettings")
    return_policy: Optional[StrictStr] = Field(default=None, description="The policy that defines the rollback of points in case of a partially returned, cancelled, or reopened [customer session](https://docs.talon.one/docs/dev/concepts/entities/customer-sessions). - `only_pending`: Only pending points can be rolled back. - `within_balance`: Available active points can be rolled back if there aren't enough pending points. The active balance of the customer cannot be negative. - `unlimited`: Allows negative balance without any limit. ", alias="returnPolicy")
    tiers: Optional[List[NewLoyaltyTier]] = Field(default=None, description="The tiers in this loyalty program.")
    __properties: ClassVar[List[str]] = ["title", "description", "subscribedApplications", "defaultValidity", "defaultPending", "allowSubledger", "usersPerCardLimit", "sandbox", "programJoinPolicy", "tiersExpirationPolicy", "tierCycleStartDate", "tiersExpireIn", "tiersDowngradePolicy", "cardCodeSettings", "returnPolicy", "tiers"]

    @field_validator('program_join_policy')
    def program_join_policy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['not_join', 'points_activated', 'points_earned']):
            raise ValueError("must be one of enum values ('not_join', 'points_activated', 'points_earned')")
        return value

    @field_validator('tiers_expiration_policy')
    def tiers_expiration_policy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['tier_start_date', 'program_join_date', 'customer_attribute', 'absolute_expiration']):
            raise ValueError("must be one of enum values ('tier_start_date', 'program_join_date', 'customer_attribute', 'absolute_expiration')")
        return value

    @field_validator('tiers_downgrade_policy')
    def tiers_downgrade_policy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['one_down', 'balance_based']):
            raise ValueError("must be one of enum values ('one_down', 'balance_based')")
        return value

    @field_validator('return_policy')
    def return_policy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['only_pending', 'within_balance', 'unlimited']):
            raise ValueError("must be one of enum values ('only_pending', 'within_balance', 'unlimited')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UpdateLoyaltyProgram from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of card_code_settings
        if self.card_code_settings:
            _dict['cardCodeSettings'] = self.card_code_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in tiers (list)
        _items = []
        if self.tiers:
            for _item_tiers in self.tiers:
                if _item_tiers:
                    _items.append(_item_tiers.to_dict())
            _dict['tiers'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UpdateLoyaltyProgram from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "title": obj.get("title"),
            "description": obj.get("description"),
            "subscribedApplications": obj.get("subscribedApplications"),
            "defaultValidity": obj.get("defaultValidity"),
            "defaultPending": obj.get("defaultPending"),
            "allowSubledger": obj.get("allowSubledger"),
            "usersPerCardLimit": obj.get("usersPerCardLimit"),
            "sandbox": obj.get("sandbox"),
            "programJoinPolicy": obj.get("programJoinPolicy"),
            "tiersExpirationPolicy": obj.get("tiersExpirationPolicy"),
            "tierCycleStartDate": obj.get("tierCycleStartDate"),
            "tiersExpireIn": obj.get("tiersExpireIn"),
            "tiersDowngradePolicy": obj.get("tiersDowngradePolicy"),
            "cardCodeSettings": CodeGeneratorSettings.from_dict(obj["cardCodeSettings"]) if obj.get("cardCodeSettings") is not None else None,
            "returnPolicy": obj.get("returnPolicy"),
            "tiers": [NewLoyaltyTier.from_dict(_item) for _item in obj["tiers"]] if obj.get("tiers") is not None else None
        })
        return _obj



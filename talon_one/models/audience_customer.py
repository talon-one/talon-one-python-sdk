# coding: utf-8

"""
    Talon.One API

    Use the Talon.One API to integrate with your application and to manage applications and campaigns:  - Use the operations in the [Integration API section](#integration-api) are used to integrate with our platform - Use the operation in the [Management API section](#management-api) to manage applications and campaigns.  ## Determining the base URL of the endpoints  The API is available at the same hostname as your Campaign Manager deployment. For example, if you access the Campaign Manager at `https://yourbaseurl.talon.one/`, the URL for the [updateCustomerSessionV2](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint is `https://yourbaseurl.talon.one/v2/customer_sessions/{Id}` 

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from talon_one.models.audience_membership import AudienceMembership
from talon_one.models.loyalty_membership import LoyaltyMembership
from typing import Optional, Set
from typing_extensions import Self

class AudienceCustomer(BaseModel):
    """
    AudienceCustomer
    """ # noqa: E501
    id: StrictInt = Field(description="The internal ID of the customer profile.")
    created: datetime = Field(description="The time this entity was created.")
    integration_id: Annotated[str, Field(strict=True, max_length=1000)] = Field(description="The integration ID set by your integration layer.", alias="integrationId")
    attributes: Optional[Dict[str, Any]] = Field(default=None, description="Arbitrary properties associated with this item.")
    account_id: StrictInt = Field(description="The ID of the Talon.One account that owns this profile.", alias="accountId")
    closed_sessions: StrictInt = Field(description="The total number of closed sessions. Does not include closed sessions that have been cancelled or reopened. See the [docs](https://docs.talon.one/docs/dev/concepts/entities/customer-sessions#customer-session-states).", alias="closedSessions")
    total_sales: Union[StrictFloat, StrictInt] = Field(description="The total amount of money spent by the customer **before** discounts are applied.  The total sales amount excludes the following: - Cancelled or reopened sessions. - Returned items. ", alias="totalSales")
    loyalty_memberships: Optional[List[LoyaltyMembership]] = Field(default=None, description="**DEPRECATED. Always returns `null`.** A list of loyalty programs joined by the customer. ", alias="loyaltyMemberships")
    audience_memberships: Optional[List[AudienceMembership]] = Field(default=None, description="The audiences the customer belongs to.", alias="audienceMemberships")
    last_activity: datetime = Field(description="Timestamp of the most recent event received from this customer. This field is updated on calls that trigger the Rule Engine and that are not [dry requests](https://docs.talon.one/docs/dev/integration-api/dry-requests/#overlay).  For example, [reserving a coupon](https://docs.talon.one/integration-api#operation/createCouponReservation) for a customer doesn't impact this field. ", alias="lastActivity")
    sandbox: Optional[StrictBool] = Field(default=None, description="An indicator of whether the customer is part of a sandbox or live Application. See the [docs](https://docs.talon.one/docs/product/applications/overview#application-environments). ")
    connected_applications_ids: Optional[List[StrictInt]] = Field(default=None, description="A list of the IDs of the Applications that are connected to this customer profile.", alias="connectedApplicationsIds")
    connected_audiences: Optional[List[StrictInt]] = Field(default=None, description="A list of the IDs of the audiences that are connected to this customer profile.", alias="connectedAudiences")
    __properties: ClassVar[List[str]] = ["id", "created", "integrationId", "attributes", "accountId", "closedSessions", "totalSales", "loyaltyMemberships", "audienceMemberships", "lastActivity", "sandbox", "connectedApplicationsIds", "connectedAudiences"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AudienceCustomer from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in loyalty_memberships (list)
        _items = []
        if self.loyalty_memberships:
            for _item_loyalty_memberships in self.loyalty_memberships:
                if _item_loyalty_memberships:
                    _items.append(_item_loyalty_memberships.to_dict())
            _dict['loyaltyMemberships'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in audience_memberships (list)
        _items = []
        if self.audience_memberships:
            for _item_audience_memberships in self.audience_memberships:
                if _item_audience_memberships:
                    _items.append(_item_audience_memberships.to_dict())
            _dict['audienceMemberships'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AudienceCustomer from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "created": obj.get("created"),
            "integrationId": obj.get("integrationId"),
            "attributes": obj.get("attributes"),
            "accountId": obj.get("accountId"),
            "closedSessions": obj.get("closedSessions"),
            "totalSales": obj.get("totalSales"),
            "loyaltyMemberships": [LoyaltyMembership.from_dict(_item) for _item in obj["loyaltyMemberships"]] if obj.get("loyaltyMemberships") is not None else None,
            "audienceMemberships": [AudienceMembership.from_dict(_item) for _item in obj["audienceMemberships"]] if obj.get("audienceMemberships") is not None else None,
            "lastActivity": obj.get("lastActivity"),
            "sandbox": obj.get("sandbox"),
            "connectedApplicationsIds": obj.get("connectedApplicationsIds"),
            "connectedAudiences": obj.get("connectedAudiences")
        })
        return _obj


